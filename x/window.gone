// Package x provides an interactive viewer for BruteRay.
package x

import (
	"fmt"

	"golang.org/x/exp/shiny/driver"
	"golang.org/x/exp/shiny/screen"
)

type event interface{}

func showWindow(title string) screen.Window {
	win := make(chan screen.Window, 1)
	go driver.Main(func(s screen.Screen) {
		w, err := s.NewWindow(&screen.NewWindowOptions{
			Title: title,
		})
		check(err)
		defer w.Release()
		win <- w
		select {}
	})
	return <-win
}

func goPipeEvents(w screen.Window) chan event {
	ch := make(chan event, 16)
	go func() {
		for {
			e := w.NextEvent()
			//printEvent(e)
			ch <- e
		}
	}()
	return ch
}

func printEvent(e interface{}) {
	format := "got %#v\n"
	if _, ok := e.(fmt.Stringer); ok {
		format = "got %v\n"
	}
	fmt.Printf(format, e)
}

/*
import (
	"fmt"
	"image"

	"os"

	"golang.org/x/exp/shiny/driver"
	"golang.org/x/exp/shiny/screen"
	"golang.org/x/mobile/event/lifecycle"
	"golang.org/x/mobile/event/paint"
	"golang.org/x/mobile/event/size"
)

type Window interface {
	Repaint()
}

func NewXWindow(title string, paint func(*image.RGBA), onEvent func(Window, interface{})) Window {
	var xwin *xWin
	onXEvent := func(w screen.Window, event interface{}) {
		onEvent(xwin, event)
	}
	ready := make(chan struct{})
	go driver.Main(func(s screen.Screen) {
		w := newWindow(s, title)
		defer w.Release()
		xwin = &xWin{w}
		close(ready)
		eventLoop(s, w, paint, onXEvent)
	})
	<-ready
	return xwin
}

type xWin struct {
	x screen.Window
}

func (w *xWin) Repaint() {
	w.x.Send(paint.Event{})
}

func eventLoop(s screen.Screen, w screen.Window, onRepaint func(*image.RGBA), onEvent func(screen.Window, interface{})) {
	var (
		winSize image.Point
		winBuf  screen.Buffer
		winTex  screen.Texture
	)

	for {
		e := w.NextEvent()
		printEvent(e)
		switch e := e.(type) {

		default:
			onEvent(w, e)

		case paint.Event:
			onRepaint(winBuf.RGBA())
			winTex.Upload(image.Pt(0, 0), winBuf, winBuf.Bounds())
			w.Copy(image.Pt(0, 0), winTex, winTex.Bounds(), screen.Over, nil)
			w.Publish()

		case size.Event:
			newSize := image.Pt(e.WidthPx, e.HeightPx)
			if winSize != newSize {
				winSize = newSize
				if winBuf != nil {
					winBuf.Release()
				}
				if winTex != nil {
					winTex.Release()
				}
				winBuf = newBuffer(s, winSize)
				winTex = newTexture(s, winSize)
			}
			w.Send(paint.Event{})

		case lifecycle.Event:
			if e.To == lifecycle.StageDead {
				return
			}
		}
	}
}

func newBuffer(s screen.Screen, size image.Point) screen.Buffer {
	b, err := s.NewBuffer(size)
	check(err)
	return b
}

func newTexture(s screen.Screen, size image.Point) screen.Texture {
	t, err := s.NewTexture(size)
	check(err)
	return t
}
*/
